## xml的序列化

```java
使用sp保存配置时自动生成了.xml文件,所以接下来的问题就是 - 我自己该如何构建.xml文件？
启动需求 : 备份短信内容;
```

* #### 假如说这是已生成的.xml文件的效果

```xml
<?xml version="1.0" encoding="utf-8"?>
<smss>
    <sms>
        <address>110</address>
        <body>你好110</body>
        <date>20190519</date>
    </sms>
    <sms>
        <address>111</address>
        <body>你好111</body>
        <date>20190520</date>
    </sms>
    <sms>
        <address>112</address>
        <body>你好112</body>
        <date>20190521</date>
    </sms>
</smss>
```

* #### 方式1 - 使用StringBuffer/Builder组拼
* ##### \[1\]、Sms实体类

```java
package com.liqun.generatexml1;

public class Sms {
    private String address; // 号码
    private String body; // 内容
    private String date; // 时间

    public String getAddress() {
        return address;
    }

    public void setAddress(String address) {
        this.address = address;
    }

    public String getBody() {
        return body;
    }

    public void setBody(String body) {
        this.body = body;
    }

    public String getDate() {
        return date;
    }

    public void setDate(String date) {
        this.date = date;
    }
}
```

* ##### \[2\]、画UI\(点击按钮触发\)

```xml
<?xml version="1.0" encoding="utf-8"?>
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent">
    <Button
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:onClick="click"
        android:textAllCaps="false"
        android:text="生成一个xml"/>
</RelativeLayout>
```

* ##### \[3\]、写对应的业务逻辑\(初始化数据、点击按钮后生成.xml并保存文件到sd卡\)

```java
...
public class MainActivity extends AppCompatActivity {
    private ArrayList<Sms> mSmsList;
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        // [1]初始化我们要备份的数据
        mSmsList = new ArrayList<>();
        for (int i = 0; i < 10; i++) {
            Sms sms = new Sms();
            sms.setAddress("11" + i);
            sms.setBody("你好," + i);
            sms.setDate("201" + i);
            mSmsList.add(sms);
        }
    }
    /**
     * 通过Stringbuffer生成一个.xml文件
     * @param view
     */
    public void click(View view) {
        // [1]创建sb对象
        StringBuffer sb = new StringBuffer();
        // [2]开始组拼xml文件头
        sb.append("<?xml version=\"1.0\" encoding=\"utf-8\"?>");
        // [3]开始组拼xml文件的根节点
        sb.append("<smss>");
        for (Sms sms : mSmsList) {
            // [4]开始组拼sms节点
            sb.append("<sms>");
            // [5]开始组拼address节点
            sb.append("<address>");
            sb.append(sms.getAddress());
            sb.append("</address>");
            // [6]开始组拼body节点
            sb.append("<body>");
            sb.append(sms.getBody());
            sb.append("</body>");
            // [7]开始组拼date节点
            sb.append("<date>");
            sb.append(sms.getDate());
            sb.append("</date>");
            sb.append("</sms>");
        }
        sb.append("</smss>");
        // [8]将数据保存到SD卡中
        File file = new File(Environment.getExternalStorageDirectory().getPath(), "smsbackup.xml");
        try {
            FileOutputStream fos = new FileOutputStream(file);
            fos.write(sb.toString().getBytes());
            fos.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

* ##### 注\* : 需要添加写SD卡的权限

```xml
<uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/>
```

* #### 方式2 - 使用XmlSerializer生成xml

```java
上述使用StringBuffer/Builder组拼xml属于"万不得已"的一种方式,而Google官方推荐使用XmlSerializer构建xml
1.官方 - 定义了一个声明xml的接口
```

* ##### 实现

```java
/**
     * 通过XmlSerializer生成一个.xml文件
     * @param view
     */
    public void click(View view) {
        // [1]获取XmlSerializer类实例
        XmlSerializer serializer = Xml.newSerializer();
        File file = new File(Environment.getExternalStorageDirectory().getPath(), "smsbackup2.xml");
        try {
            FileOutputStream fos = new FileOutputStream(file);
            // [2]设置XmlSerializer序列化器参数
            serializer.setOutput(fos,"utf-8"); // encoding:写入文件时所采用的编码方式
            // [3] 写xml文档开头 encoding:指定文件的编码方式 standalong:是否独立、没有其他修饰
            serializer.startDocument("utf-8",true);
            // [4]写xml根节点
            serializer.startTag(null,"smss");
            // [5]循环写sms节点
            for (Sms sms : mSmsList) {
                serializer.startTag(null, "sms");
                // [5.1]写address节点
                serializer.startTag(null, "address");
                serializer.text(sms.getAddress());
                serializer.endTag(null, "address");
                // [5.1]写body节点
                serializer.startTag(null, "body");
                serializer.text(sms.getBody());
                serializer.endTag(null, "body");
                // [5.1]写date节点
                serializer.startTag(null, "date");
                serializer.text(sms.getDate());
                serializer.endTag(null, "date");
                serializer.endTag(null, "sms");
            }
            serializer.endTag(null, "smss");
            serializer.endDocument();
            fos.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
```

## xml的解析



