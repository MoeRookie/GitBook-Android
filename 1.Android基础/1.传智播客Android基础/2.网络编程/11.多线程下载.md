## 原理

```java
1.可以理解为"司马光砸缸"多砸了几个口
2.亦可以理解为"多个人帮你抢票"提高概率, 也就是说 更多的cpu资源给到了你
3.要注意:
    1). 并不是说线程开的越多下载的就越快[手机迅雷建议使用3~4个线程即可](极限分析: 开足够的线程,cpu就会把时间全部浪费在时间片的切换上)
    2). 多线程下载的速度还受带宽影响(极限分析: 咱家2M的带宽的下载速度绝对比不上百度20M带宽的下载速度)
```

## 下载步骤![](/assets/多线程下载文件的步骤.png)

```java
1. 服务器上存有待下载的文件, 客户端需要下载此文件到本地
2. 既然是多线程下载, 那么每个线程下载的内容就要等分, 而且, 所有线程下载结束后算下载结束
3. 所以, 多线程下载的步骤为:
    1). 获取服务器上待下载文件的大小(等分、计算每个线程下载的起止位置)
    2). 在客户端创建一个大小和服务器一模一样的文件, 提前申请好空间(非必须)
    3). 计算每个线程下载的开始位置和结束位置
    4). 开多个线程去下载文件
    5). 知道每个线程什么时候下载结束了.
```

## 多线程下载

* ### 核心逻辑

  ```java
  ...
  public class MutilDownload {
      // [1]定义下载的路径
      static String path = "http://192.168.1.106:8080/PCQQ2019.exe";
      private static final int THREAD_COUNT = 3; // 要下载的线程数
      private static int runningThread; // 记录正在运行线程的个数
      public static void main(String[] args) {
          try {
              // [一]获取服务器文件大小(要计算每个线程下载的开始位置和结束位置)
              // [1]创建一个url对象(参数即为网址)
              URL url = new URL(path);
              // [2]获取httpURLConnection连接对象
              HttpURLConnection conn = (HttpURLConnection) url.openConnection();
              // [3]设置参数, 发送get请求
              conn.setRequestMethod("GET");
              // [4]设置连接网络的超时时间
              conn.setConnectTimeout(5000);
              // [5]获取服务器返回的状态码
              int code = conn.getResponseCode(); // 200代表获取服务器资源成功 206代表请求到了部分资源
              if(code == 200) {
                  // [6]获取服务器文件的大小(字节)
                  int length = conn.getContentLength();
                  runningThread = THREAD_COUNT;
                  // [二]创建一个大小和服务器一模一样的文件(以提前把空间申请出来)
                  RandomAccessFile raf = new RandomAccessFile(getFileName(path), "rw");
                  raf.setLength(length);
                  // [7]算出每个线程下载的大小
                  int blockSize = length/THREAD_COUNT;
                  // [三]计算每个线程下载的开始位置和结束位置
                  for(int i=0;i<THREAD_COUNT;i++) {
                      int startIndex = i*blockSize;
                      int endIndex = (i+1)*blockSize-1;
                      // 特殊情况就是最后一个线程
                      if(i == THREAD_COUNT-1) { // 说明是最后一个线程
                          endIndex = length-1;
                      }
                      System.out.println("线程id::"+i+"理论下载的位置:"+startIndex+"-----"+endIndex);
                      // [四]开启线程去服务器下载文件
                      DownloadThread thread = new DownloadThread(startIndex, endIndex, i);
                      thread.start();
                  }
                  System.out.println("length = " + length);
              }
          } catch (Exception e) {
              // TODO Auto-generated catch block
              e.printStackTrace();
          }
      }
      // 定义线程去服务器下载文件
      private static class DownloadThread extends Thread{
          private int startIndex;
          private int endIndex;
          private int threadId;
          public DownloadThread(int startIndex,int endIndex,int threadId) {
              this.startIndex = startIndex;
              this.endIndex = endIndex;
              this.threadId = threadId;
          }
          @Override
          public void run() {
              // [四]实现去服务器下载文件的逻辑
              try {
                  // (1)创建一个url对象(参数就是网址)
                  URL url = new URL(path);
                  // (2)获取httpURLConnection连接对象
                  HttpURLConnection conn = (HttpURLConnection) url.openConnection();
                  // (3)设置参数,发送get请求
                  conn.setRequestMethod("GET"); // 默认请求就是GET, 注意要大写
                  // (4)设置连接网络的超时时间
                  conn.setConnectTimeout(5000);
                  // (4.0) 如果中间断过,从上次的位置继续下载(需要从文件中读取上次下载的位置)
                  File file = new File(getFileName(path)+threadId+".txt");
                  if(file.exists() && file.length()>0) {
                      FileInputStream fis = new FileInputStream(file);
                      BufferedReader br = new BufferedReader(new InputStreamReader(fis));
                      String lastPos = br.readLine(); // 读取出来的内容就是上一次下载的位置
                      int lPos = Integer.parseInt(lastPos);
                      startIndex = lPos+1; // 改变一下startIndex的位置
                      System.out.println("线程id::"+threadId+"真实下载的位置:"+startIndex+"-----"+endIndex);
                  }
                  // (4.1)设置一个请求头range(作用是告诉服务器每个线程下载的开始位置和结束位置)
                  conn.setRequestProperty("Range", "bytes="+startIndex+"-"+endIndex);
                  // (5)获取服务器返回的状态码
                  int code = conn.getResponseCode(); // 200代表服务器全部资源请求成功,206代表服务器部分资源请求成功
                  if(code == 206) {
                      // (6)创建随机随即读写文件对象
                      RandomAccessFile raf = new RandomAccessFile(getFileName(path), "rw");
                      // (7)每个线程要从自己的位置开始写
                      raf.seek(startIndex);
                      InputStream is = conn.getInputStream(); // 存的是QQ.exe
                      // (8)把数据写到文件中
                      int len = -1;
                      byte[] buffer = new byte[1024*1024];
                      int total = 0; // 代表当前线程下载的大小
                      while((len = is.read(buffer))!=-1) {
                          raf.write(buffer,0,len);
                          total += len;
                          // [9]实现断点续传就是把当前线程下载的位置给存起来,下次再下载的时候接着上次的下载位置继续下载就可以了
                          int currentPos = startIndex + total; // 存到一个普通的.txt文本中
                          // [10]用来存当前线程下载的位置
                          RandomAccessFile raff = new RandomAccessFile(getFileName(path)+threadId+".txt", "rwd");
                          raff.write(String.valueOf(currentPos).getBytes());
                          raff.close();
                      }
                      raf.close(); // 关闭流,释放资源
                      System.out.println("线程id:" + threadId + "---下载完毕了---");
                      synchronized (DownloadThread.class) {
                          runningThread--;
                          if(runningThread == 0) { // 说明所有的线程都执行完毕了,就把 .txt 文件删除
                              for(int i=0;i<THREAD_COUNT;i++) {
                                  File delFile = new File(getFileName(path)+i+".txt");
                                  delFile.delete();
                              }
                          }
                      }

                  }
              } catch (Exception e) {
                  // TODO Auto-generated catch block
                  e.printStackTrace();
              }
          }
      }
      /**
       * 获取文件的名字
       * @param path eg.http://192.168.11.73:8080/feiq.exe
       * @return 文件名
       */
      private static String getFileName(String path) {
          int start = path.lastIndexOf("/")+1;
          String name = path.substring(start);
          return name;
      }
  }
  ```





