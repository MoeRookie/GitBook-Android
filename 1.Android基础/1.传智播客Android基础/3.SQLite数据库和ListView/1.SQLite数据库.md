## 数据库介绍

```java
1.数据库是用于存储数据的特殊文件;
2.Android中使用内嵌的轻量级SQLite数据库;
3.当有大量相似结构的数据需要存储的时候就需要用到数据库;
- 数据库中存放的是数据库表,数据库表中存放了大量相似甚至相同结构的数据;
- 由于使用了特殊算法设计数据库表,故其特别适合查询等应用场景;
```

## 数据库的创建

* #### \[1\]、自定义类继承SQLiteOpenHelper

```java
概念:用于管理数据库创建和版本管理的帮助类;
...
public class MyOpenHelper extends SQLiteOpenHelper {
    /**
     * @param context 上下文
     * @param name 数据库名
     * @param cursor 封装了结果集的对象(指针)
     * @param version 数据库版本 从1开始
     */
    public MyOpenHelper(Context context) {
        super(context, "MoeRookie.db", null, 1);
    }

    @Override
    public void onCreate(SQLiteDatabase db) {
    }

    @Override
    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
    }
}
```

* #### \[2\]、创建或打开数据库

```java
public class MainActivity extends AppCompatActivity {
    private MyOpenHelper mOpenHelper;
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        // 创建数据库的帮助类对象
        mOpenHelper = new MyOpenHelper(getApplicationContext());
        // 打开或创建数据库(如果是第一次调用就是创建)
        SQLiteDatabase sqLiteDatabase = mOpenHelper.getWritableDatabase();
        // 打开或创建数据库(如果是第一次调用就是创建).如果磁盘满了,则返回只读内容
        // SQLiteDatabase readableDatabase = mOpenHelper.getReadableDatabase();
    }
}
```

## onCreate方法

* #### 细节
* ##### 1、当数据库第一次创建的时候调用

```java
故此方法特别适合表结构的初始化(创建表就是写sql语句)
```

* ##### 2、使用sql语句创建表

```java
1.id字段根据规范一般写成_id的格式;
2.SQLite数据库底层为了运行效率将数据统一成字符串类型,所以以下实现中的integer可为varchar、name的长度实际上也不受限制,
  而写成标准sql语句的原因就在于为保证协同开发时不至于写出其他开发者不明确的sql代码;
3.通常不自己写指定的sql语句,而是拿网上的相关代码作修改,因为容易写错;
```

* #### 实现

```java
...
/**
 * Called when the database is created for the first time.
 * - 当数据库第一次创建的时候调用
 * - 故此方法特别适合表结构的初始化(写sql语句)
 */
@Override
public void onCreate(SQLiteDatabase db) {
    // id - 一般写成_id格式
    db.execSQL("create table info(_id integer primary key autoincrement,name varchar(20))");
}
...
```

#### 关于数据库工具 - NavicatPremium

* ##### 1、新建SQLite连接
* ##### 2、输入连接名、本地数据库文件地址等连接信息
* ##### 3、打开连接查看数据库表

## onUpgrade方法

* #### 细节
* ##### 1、当数据库版本升级的时候调用

```java
故此方法特别适合做表的更新(表结构、增删表等)
eg.1.0版本的表结构中字段不够用时要添加新字段的情况下;
```

* ##### 2、使用sql更新表

```java
1.过程
- 1).修改自定义帮助类构造方法的version值
- 2).在onUpgrade(...)方法中执行sql语句更新表
2.细节
- 1).在企业级开发中,一般会根据oldVersion和newVersion的选择判断添加不同的更新表的逻辑;
- 2).SQLite数据库不支持"降级",降级会报错 - eg.Can't downgrade database from version 3 to 2
```

* #### 实现

```java
...
/**
 * Called when the database needs to be upgraded
 * 当数据库版本升级的时候调用
 * 那么这个方法特别适合做 表的更新(表结构、增删表等)
 */
@Override
public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
    db.execSQL("alter table info add phone varchar(20)");
}
...
```

## SQL增删改查

```java
需求: 点击插入、删除、修改和查找四个按钮实现SQLite数据库的增删改查操作
```

* #### 实现

```java
...
/**
 * 插入一条数据
 * @param view
 */
public void insert(View view) {
    // [1]获取数据库对象
    SQLiteDatabase database = mHelper.getWritableDatabase();
    // [2]执行插入一条记录的sql语句
    database.execSQL("insert into info(name,phone) values(?,?)",new String[]{"狗娃","15163605898"});
    // [3]数据库用完需要关闭
    database.close();
}

/**
 * 删除一条数据
 * @param view
 */
public void delete(View view) {
    // [1]获取数据库对象
    SQLiteDatabase database = mHelper.getWritableDatabase();
    // [2]执行删除一条记录的sql语句
    database.execSQL("delete from info where name=?",new String[]{"狗娃"});
    // [3]数据库用完需要关闭
    database.close();
}

/**
 * 更新一条数据
 * @param view
 */
public void update(View view) {
    // [1]获取数据库对象
    SQLiteDatabase database = mHelper.getWritableDatabase();
    // [2]执行更新一条记录的sql语句
    database.execSQL("update info set phone=? where name=?",new String[]{"18401250561","狗娃"});
    // [3]数据库用完需要关闭
    database.close();
}

/**
 * 查找一条数据
 * @param view
 */
public void select(View view) {
    // [1]获取数据库对象
    SQLiteDatabase database = mHelper.getReadableDatabase();
    // [2]执行查询语句获取结果集游标
    Cursor cursor = database.rawQuery("select * from info", null);
    if (cursor != null && cursor.getCount() > 0) {
        while (cursor.moveToNext()) { // [3]移动到下一行
            String name = cursor.getString(1); // [4]获取列值
            String phone = cursor.getString(2);
            Log.e(TAG, name + " , " + phone);
        }
    }
}
...
```

* #### 细节

```java
cursor.get...(...)方法是意味着要SQLite数据库底层返回对应类型的值;
底层数据都以字符串类型保存,所以通过此方法获取值时会自动做类型转换;
```

* #### 注意

```java
在使用sql语句对数据库进行增删改查时存在以下缺陷
1.sql语句容易写错
2.执行sql语句后没有返回值,不利于判断操作结果
```

## 使用命令行打开数据库

* #### sqlite3命令行工具

```java
1.首先要获取到root权限;
2.adb shell进入手机终端;
3.cd data/data/com.liqun.sqlite/databases进入到SQLite数据库文件所在目录;
4.sqlite3 MoeRookie.db打开数据库;
5.select * from info;查询info表中的所有数据;
```

* #### 乱码问题

```java
1.SQLite数据库底层储存的数据采用了utf-8的的编码方式;
2.win的命令行默认使用gbk的编码方式,故查询到的中文数据是乱码;
3.使用chcp 936 / chcp 65001可将dos的编码方式修改为gbk/utf-8;
```

## 使用API进行增删改查

* ### "增"
* #### 实现

```java
...
/**
 * 插入一条数据
 * @param view
 */
public void insert(View view) {
    // [1]获取数据库对象
    SQLiteDatabase database = mHelper.getWritableDatabase();
    // [2]执行插入一条记录的sql语句
    ContentValues values = new ContentValues();
    values.put("name", "够娃");
    values.put("phone", "15163605898");
        // table:表名
        // nullColumnHack:null
        // values:ContentValues类型;key - 对应列的名字,value - 列对应的值
    long id = database.insert("info", null, values);// 返回值代表插入新行的ID
    // [3]数据库用完需要关闭
    database.close();
    Toast.makeText(this,
            id!=-1 ?
            "添加成功":"添加失败", Toast.LENGTH_SHORT).show();
}
...
```

* #### 源码
* ##### 实现

```java
...
/**
 * General method for inserting a row into the database.
 *
 * @param table the table to insert the row into
 * @param nullColumnHack optional; may be <code>null</code>.
 *            SQL doesn't allow inserting a completely empty row without
 *            naming at least one column name.  If your provided <code>initialValues</code> is
 *            empty, no column names are known and an empty row can't be inserted.
 *            If not set to null, the <code>nullColumnHack</code> parameter
 *            provides the name of nullable column name to explicitly insert a NULL into
 *            in the case where your <code>initialValues</code> is empty.
 * @param initialValues this map contains the initial column values for the
 *            row. The keys should be the column names and the values the
 *            column values
 * @param conflictAlgorithm for insert conflict resolver
 * @return the row ID of the newly inserted row OR <code>-1</code> if either the
 *            input parameter <code>conflictAlgorithm</code> = {@link #CONFLICT_IGNORE}
 *            or an error occurred.
 */
public long insertWithOnConflict(String table, String nullColumnHack,
        ContentValues initialValues, int conflictAlgorithm) {
    acquireReference();
    try {
        StringBuilder sql = new StringBuilder();
        sql.append("INSERT");
        sql.append(CONFLICT_VALUES[conflictAlgorithm]);
        sql.append(" INTO ");
        sql.append(table);
        sql.append('(');

        Object[] bindArgs = null;
        int size = (initialValues != null && !initialValues.isEmpty())
                ? initialValues.size() : 0;
        if (size > 0) {
            bindArgs = new Object[size];
            int i = 0;
            for (String colName : initialValues.keySet()) {
                sql.append((i > 0) ? "," : "");
                sql.append(colName);
                bindArgs[i++] = initialValues.get(colName);
            }
            sql.append(')');
            sql.append(" VALUES (");
            for (i = 0; i < size; i++) {
                sql.append((i > 0) ? ",?" : "?");
            }
        } else {
            sql.append(nullColumnHack + ") VALUES (NULL");
        }
        sql.append(')');

        SQLiteStatement statement = new SQLiteStatement(this, sql.toString(), bindArgs);
        try {
            return statement.executeInsert();
        } finally {
            statement.close();
        }
    } finally {
        releaseReference();
    }
}
...
```

* ##### 描述

```java
1.数据库增删改查的方法底层就是在组拼sql语句;
2.当nullColumnHack传null时,对应的sql语句为:instert into into(null) values(NULL)[才符合sql的书写格式]
3.于是"删、改、查"的方法底层亦是在组拼sql语句,故重点关注其参数和返回值(方法的解释即可);
```

* ### "删、改、查"

```java
...
/**
 * 删除一条数据
 * @param view
 */
public void delete(View view) {
    // [1]获取数据库对象
    SQLiteDatabase database = mHelper.getWritableDatabase();
    // [2]执行删除一条记录的sql语句
    int rows = database.delete("info", "name = ?", new String[]{"狗娃"});// 返回值代表被影响的行数
    // [3]数据库用完需要关闭
    database.close();
    Toast.makeText(this, "删除了"+rows+"行", Toast.LENGTH_SHORT).show();
}

/**
 * 更新一条数据
 * @param view
 */
public void update(View view) {
    // [1]获取数据库对象
    SQLiteDatabase database = mHelper.getWritableDatabase();
    // [2]执行更新一条记录的sql语句
    ContentValues values = new ContentValues();
    values.put("phone","18401250561");
    int rows = database.update("info", values, "name = ?", new String[]{"狗娃"}); // 代表更新了多少行
    // [3]数据库用完需要关闭
    database.close();
    Toast.makeText(this, "更新了"+rows+"行", Toast.LENGTH_SHORT).show();
}

/**
 * 查找一条数据
 * @param view
 */
public void select(View view) {
    // [1]获取数据库对象
    SQLiteDatabase database = mHelper.getReadableDatabase();
    // [2]执行查询语句获取结果集游标
    // columns:要查询的列
    // selection:查询条件
    Cursor cursor = database.query(
            "info", 
            new String[]{"name", "phone"},
            "name = ?", new String[]{"狗娃"}, null, null, null);
    if (cursor != null && cursor.getCount() > 0) {
        while (cursor.moveToNext()) { // [3]移动到下一行
            String name = cursor.getString(0); // [4]获取列值
            String phone = cursor.getString(1);
            Log.e(TAG, name + " , " + phone);
        }
    }
}
...
```

* #### 说明

  * ##### 1. 若要查询指定表中的所有数据 , 则 columns 参数填 null 即可.
  * ##### 2. 指定查询列后 , 意义列下标从0开始。
* ### 优缺点

```java
优:
    写法简单,不需要写复杂的sql语句,不容易写错;
    有返回值,方便开发者进行开发;
缺:
    如果有多张表,使用此API就不容易进行查询;
```

## 事务

* ### 概念

```java
1.执行一段逻辑,要么同时成功、要么同时失败;
2.eg:银行转账;
```

* ### 实现

```java

```



